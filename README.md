# java-racingcar

자동차 경주 미션 저장소

## 기능 명세

1. 자동차 이름 입력
   1. 이름은 ','로 구분해야 한다.
   2. 이름은 다섯자 이하여야 한다.
   3. 이름은 중복되지 않아야 한다.
   4. 이름의 앞, 뒤에 위치하는 공백은 제거된다.
2. 이동 횟수 입력
   1. 이동 횟수는 자연수여야 한다.
3. 각 라운드마다 현재 상태를 출력
   1. 0~9 사이의 랜덤한 정수 값을 이용해 전진 여부 결정
   2. 각 자동차별로 현재 위치 출력
4. 최종 우승자를 출력
   1. 위치의 최댓값 탐색
   2. 우승자 결정
   3. 최종 우승자 출력
      1. 최종 우승자가 여러명이면 ','로 구분한다.


## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

## 리뷰 내용 정리

### 구현을 하며

페어인 아토와 구현을 할 때 정했던 원칙은 "돌아가는 쓰레기 먼저, 필요할 때 리팩토링" 이었다.
오버엔지니어링을 피하기 위해, 그리고 문제 해결에 사용되는 다양한 방법들의 장점을 확실히 느끼기 위해 이런 원칙을 정했다.

### Step 1

#### - 패키지

> 현재 패키지로 구분없이 하나의 폴더에 모든 자바 파일을 생성하셨는데, 의도가 있었을까요? 현재의 방식대로 만든다면 어떤 단점이 있을지 생각해보면 좋을 것 같아요 😊

실무에서는 여러가지 비용의 제약이 존재한다고 생각했고, 우리가 "좋은 코드를 작성하기 위해 무의식적으로 작성하던 것들"이 왜 필요한지를 고민해 보고 싶었다.
궁극적으로 좋은 코드를 작성하기 위해서라면
1. 각각의 클래스를 논리적인 단위의 패키지로 구분해 분류해 둘 수 있으며
2. 서로 연관된 클래스들만 하나의 패키지에 위치 시키면 이후 접근 제어자의 설정으로 패키지 내에서만 공유할 수 있는 메서드 등을 구현할 수 있다.
라는 장점들을 생각하며 패키지를 나눌 수 있을 것 같다.

아직은 패키지를 나눌 필요성을 크게 체감하지 못해 패키지 구분이 없는 코드를 사용했다.

#### - 기능 요구사항

>0~9 사이의 랜덤 값이 들어온다는 요구사항도 있네요!
기능 명세서를 조금 더 자세하게 작성해보는 것은 어떨까요?

나는 기능 명세서를 구현에 대한 내용 없이 최대한 간단하게 작성하고 넘어가는 것을 선호한다. 
기능 명세서를 일종의 "프로그램 동작을 정의하는 인터페이스" 정도로 정의하기 때문이다.
즉, 기능 명세서는 프로그램의 동작만 잘 설명하면 되며 오히려 내부 구현을 설명하는 순간 "프로그램의 동작 설명"이라는 목적을 잃기 쉽다고 생각했다.

다만, 최대한 단순하게 작성하려다 보니 꼭 필요한 요구사항인 "랜덤 값" 의 내용을 놓치게 되었다.

**요구사항은 최대한 간결하게, 하지만 꼭 필요한 내용을 모두 포함하도록 작성해 보자.**


#### - 컨벤션
> 상수와 인스턴스 변수 사이에 공백을 두면 한 눈에 분리해서 볼 수 있어 가독성이 더 좋아질 것 같아요 😊

> POSIX new line에 대해 알아볼까요?
인텔리제이 자동 개행 설정도 가능합니다~!

#### - 메서드 분리

```java
if (name == null || name.isBlank() || name.length() > MAX_NAME_LENGTH) {
    throw new IllegalArgumentException("잘못된 이름입니다.");
}
```
> 메서드로 분리해볼까요?

돌아가는 쓰레기에서 미처 리팩토링을 진행하지 못한 부분.
가독성을 위해서라도, 조건문의 조건에 해당하는 부분은 최대한 간결하게 유지하도록 하자.
많은 조건을 확인해야 한다면 메서드로 분리해 메서드 명으로 확인하는 조건을 잘 나타내 볼 수 있다.

```java
if (names.stream().distinct().count() != names.size()) {
```
> 한줄에 stream().distinct().count() 가 있으니 가독성이 떨어집니다!

마찬가지로, 조건문에서는 로직을 최대한 배제시키는 것이 가독성에 좋다.
위의 `stream().distinct().count()` 는 변수로 추출하는 것이 훨씬 좋다.

> 또한, 어떤 경우에도 같은 예외 메시지가 나타나게 되는데, 이렇게 되면 자동차 게임을 실행하는 사람 입장에서 너무 불편할 것 같아요.

예외 메시지도 사용자 친화적으로 작성을 해 주는 것이 좋다.

#### - 클래스의 책임을 최소화시키자.

> `Car` 이라는 객체가 `NumberGenerator`를 알아야 할까요?
해당 클래스 외부에서 자동차를 만들려고 하는데 이름 외에 `NumberGenerator`가 있으면 당황스럽지 않을까요? 😢

이 부분은 Step2에서 다시 한번 리뷰를 받게 되는 부분이기에 우리가 이해하고, 리팩토링한 방향을 기록해 둔다.

과연 `Car` 클래스는 "숫자를 생성하는 책임"이라는 것을 가지는 것이 자연스러운가?
그렇지 않다고 본다. `Car` 클래스는 단순히 "움직인다" 라는 역할을 수행하기 위해 생겨난, "움직이는 객체" 이다.
이런 시선에서 본다면 `Car` 객체 내부에 `NumberGenerator`가 존재하는 것 역시 어색하게 느껴지는 것이다.

그렇다면, 자동차가 스스로 움직이기 위해 어떤 로직을 포함해야 할까?
결국, 나는 자동차가 "어떤 상황에서" 움직일지를 선택할 수 있도록 `boolean canGo()` 메서드를 가지는 `MoveStrategy` 인터페이스를 사용하게 되었다.
`Car.tryMove()` 메서드를 `Car.tryMove(int generatedValue)`처럼 외부에서 수를 생성하고 `Car`에게 넘겨주는 방법도 있었으나, 항상 숫자를 통해서만 `Car`가 움직이지만은 않을 것이라 생각했다.
즉, 확장성을 고려하기 위해 이런 방법을 선택했다.

#### - 테스트를 위해 존재하는 코드

```java
public Cars(List<Car> cars) {
  this.cars = cars;
}
```
> 해당 메서드는 테스트에서만 사용되고 있네요.
테스트 코드 때문에 운영 코드에 추가/변경이 생기게 된다면 관리하기 힘들어질 것 같아요 😢

썬이 남겨 주셨던, Cars(List<Car> cars) 생성자가 테스트 코드만을 위한 코드라는 리뷰를 보며 가장 많은 고민이 들었습니다.

저와 아토 역시 동일한 이유로 해당 생성자를 만드는 것을 마지막까지 고민했었는데요.
결국, 각각의 자동차마다 별개의 이동 전략 (이전에는 숫자 생성 전략)을 할당해 주지 않으면 우승자 이름을 조회하는 로직을 테스트하기 위해 각각의 차를 다른 곳에 위치시킬 수 없었습니다.
모든 자동차가 동일한 이동 전략을 공유할 것이기 때문입니다.

즉, 비즈니스 코드와는 다르게 테스트 코드에 한정적으로 "각각의 자동차에 다른 이동 전략을 할당"해야 할 필요성이 생겼고, 이를 위해 해당 생성자를 사용하게 되었습니다.

아직까지는 해당 생성자를 사용하는 것 보다 더 좋은 방법을 찾아내지 못했습니다.
또한, 한편으로는 "테스트 코드를 위해 비즈니스 코드가 분리되는 상황"이 자연스러운 흐름처럼 느껴지기도 하고요.
때로는 테스트를 하기 수월한 코드를 만들기 위해서 제어할 수 없는 역할들을 분리해 내기도 한다고 생각해요. 물론, 대부분의 경우 해당 이유와 함께 코드의 응집도를 높이고, 하나의 클래스에는 하나의 책임만을 두기 위함이라는 목적도 있겠지만요.
어떤 방법이 있을지, 그리고 어떤 기준으로 여러 방법들을 판단해야 할 지는 제가 더 고민을 해 봐야 코드로 보여드릴 수 있을 것 같아요. 아쉽지만, 조금만 더 지켜봐 주시면 감사할 것 같습니다!

>👍👍👍 너무 좋습니다! 짱수가 말씀하신 이유에 충분히 설득됐습니다. 생성자 정도는 테스트코드를 위해 더 추가해도 될 것 같아요.
>또한, 객체에 대한 설계가 항상 하나로 정해져 있지는 않아 다양한 생성자가 있을수록 더 유연한 개발이 가능하구요.

#### - 스트림

> winnerNames를 만들어 추가하는 것보다 스트림을 돌면서 한번에 list names를 꺼내볼 수 있지 않을까요?~

for 문을 순회하면서 생성된 `List`에 각 객체를 추가하는 것과, 스트림을 사용해서 각 객체를 포함하는 `List`를 생성하는 것의 차이는 다음과 같다.

1. for 문을 사용하는 경우

- 리스트 생성, 내부 객체 생성 및 추가, 리스트 반환과 같이 필요한 `List`를 반환하기 위한 로직이 세 개의 개별적인 로직으로 구분된다.

2. Stream 을 사용하는 경우

- 내부 객체의 생성부터 리스트 반환까지의 전체 과정이 하나의 `Stream`으로 표현될 수 있다.
- 반환 값이 `Collections.unmodifiableList` 이기에 불변성을 제공할 수 있다.

어짜피 리스트의 변경을 허용하는 메서드를 제공하지 않기에 불변성에 대한 장점은 큰 의미가 없다고 생각된다.
하지만, 전체 과정을 하나의 `Stream`으로 표현할 수 있다면 가독성도 좋아질 뿐더러 for문에서와 달리 로직 중간에 잘못된 연산이 포함될 가능성을 크게 줄일 수 있다고 생각하여 리뷰의 방향대로 리팩토링 하였다.

#### - 인스턴스 생성 방지

> 정적 함수로 이루어진 클래스라면 private 생성자를 통해 다른 곳에서 의도치 않은 객체 생성을 못하도록 막아봅시다

#### - 테스트 코드

> ParameterizedTest 활용 👍
다만, 입력 값에 대한 검증을 각각 하지 않고 있어 공백에 대한 테스트인줄 알고 보다가 zzangsu가 왜 예외를 발생시키는지 헷갈릴 것 같아요. 예외 메시지를 세분화해보는건 어떨까요?

`ParameterizedTest`를 사용할 때 역시 모든 실패 케이스를 하나의 테스트에서 작성하는 것 보다 각각의 케이스들을 세분화하여 작성을 하는 것이 "문서"로써의 테스트 코드 역할을 더 잘 수행할 수 있게 해준다고 생각한다.

>+) 이름에 대한 테스트라면 CarNameTest를 만들어보는건 어떨까요?

(리뷰에 대한 답글)
CarNameTest에 대해...

이름에 대한 예외 사항들을 CarName에서 처리해 주고 있기 때문에 CarNameTest에서 테스트를 해 주는 것이 적절하다는 생각이 들었고, CarTest에 존재하던 이름과 관련된 테스트 내용들을 CarNameTest로 분리했습니다.

그런데, 이 과정에서 궁금한 점이 생겼는데요.
Car 역시 이름을 인자로 받아 적절한 이름일 때만 생성되어야 합니다. 물론, 제가 직접 짠 코드이기에 저는 "잘못된 이름이 입력되면 CarName에서 예외를 발생시켜 주고, 이 예외 덕분에 Car에서 역시 정상적으로 예외를 넘겨 받을 수 있다."는 사실을 알고 있어요.
하지만, 제가 머릿속으로 아는 것과 코드로 테스트코드를 작성해 문서화 해 두는 것은 다른 문제라고 생각합니다.

그렇게 생각하고 나니 CarTest에서 역시 잘못된 이름을 사용했을 때 올바르게 예외가 발생하는지 확인해 주는 테스트가 있어야 할까? 라는 고민이 생겼습니다.

물론, 두 방법은 트레이드 오프가 존재할 것 같아요.
CarTest에서 잘못된 이름에 대한 테스트를 작성해 주는 것이 코드를 더 확신할 수 있도록 해준다고 생각하지만, 이를 위해 "굳이" CarNameTest에 있는 테스트를 한번 더 해 주는 것이 "효율적"이진 않을 것 같다고 생각해요. 동일한 내용의 테스트를 두 곳에서 중복으로 해 주기 때문에 CarTest 내부의 잘못된 이름에 대한 테스트는 유의미한 테스트가 되기는 어려울 것 같아요.
그럼에도, "혹시나 나중에 예외 처리 방법이 변경되었을 경우" 해당 부분의 테스트를 놓칠 가능성을 줄일 수 있지 않을까요??

정말 여러 기준들 사이에서 저만의 적절한 트레이드 오프 기준을 찾는 것은 어려운 것 같습니다. 썬의 경우 CarTest에서 "중복하여" 이름에 대한 예외 상황을 검증하는 것에 대해 어떻게 생각하나요?

> (답글)
> 저라면 CarTest 객체 내부에서 중복으로 이름에 대한 예외 상황을 테스트하지 않을 것 같아요 !
단일 책임 원칙에 의하면 각 객체의 책임은 명확하게 분리되어야 합니다.
Car 객체가 주로 자동차의 동작과 상태를 관리하는 역할이라면, CarName 객체는 자동차의 이름과 같은 특정 데이터를 캡슐화하는 하나의 값 객체입니다.
따라서 Car와 CarName을 독립적으로 테스트하고, 각 객체의 책임에 맞는 테스트 코드를 작성함으로써 코드의 의도가 명확해지고, 유지보수성이 향상될 것 같아요. 😄
>
>혹시나 예외 처리 방법이 변경될 경우는 CarName에 대한 테스트 코드에서 충분히 잡을 수 있지 않으까요? Car에서 생성했던 테스트가 정책에 맞지 않다면 테스트 코드가 통과되지 않을 것 같아서요!
>
>ps) 테스트 코드의 메서드명에서도 의도가 명확했으면 좋겠습니다! 물론 DisplayName을 통해 어떤 테스트인지 알 수 있지만, 코드 상으로도 통일되도록 테스트 코드의 목적을 명확히 전달하도록 작성해보는건 어떨까요?

#### 예외 메시지

>세분화된 예외 메시지 👍
>
>조금 더 나아가자면 현재 메시지의 경우, 만약 최소 시도 횟수에 대한 요구사항이 변경된다면 에러 메시지도 같이 변경되어야해요!  
`String.format()`을 사용해 만들어두신 상수를 이용한다면 추후 변경에 용이할 수 있습니다! 😊

#### getter를 사용하는 대신 객체에 메시지를 보내자

>filter 내부도 위치 값을 꺼내오기보다는 자동차에게 메시지를 보내볼까요?

[getter를 사용하는 대신 객체에 메시지를 보내자](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/)
객체에게 getter를 사용하는 대신 객체에게 메시지를 보내는 이유를 요약해 둔다.
객체의 getter를 구현하는 방법은 객체의 정보를 외부로 보여주며 캡슐화를 지키는 것을 방해한다.
객체의 값이 외부에서 변경될 수 있는 가능성도 존재하지만, 이를 해결하더라도 여전히 문제는 존재한다.
이렇게 객체 내부의 값이 외부로 노출되면서 객체가 가져야 하는 책임이 외부로 이동할 가능성이 생기는 것이다.

### Step 2

## 피드백 내용 정리


